
# тут просто какие-то куски кода, которые можно потыкать в основной программе
# использовал для тестов и проверок чего
# но чтоб не удалять и мб понадобится потом помещу сюда


# -------------------------------------------------------------------------
# построение линий изменения тона изображения

    # x = [i for i in range(900)]
    #
    # rotated_image = np.rot90(images['2-17.tif'])
    # print(np.shape(rotated_image))
    # y = [rotated_image[65][i][0] for i in range(900)]
    #
    # plt.plot(x, y, label='65')
    # plt.legend()
    # plt.show()
# -------------------------------------------------------------------------


# -------------------------------------------------------------------------
# построение графиков вдоль широкой грани изображения
# и попытка интерполировать кривую

    x = [i for i in range(4201)]

    rotated_image = np.rot90(images['2-4.tif'])
    print(np.shape(rotated_image))
    y = [rotated_image[500][i][0] for i in range(4201)]

    #fig, ax = plt.subplots(3, 1)
    plt.figure(1)

    plt.subplot(4, 1, 1)
    plt.plot(x, y, label='500')
    plt.legend()

    y = [rotated_image[1500][i][0] for i in range(4201)]
    plt.subplot(4, 1, 2)
    plt.plot(x, y, label='1500')
    plt.legend()

    y = [rotated_image[2500][i][0] for i in range(4201)]
    plt.subplot(4, 1, 3)
    plt.plot(x, y, label='2500')
    plt.legend()

    plt.subplot(4, 1, 4)
    t = np.polyfit(x, y, 40)    # интерполяция полиномом 40 степени
    f = np.poly1d(t)
    x_l = np.linspace(0, 4000, 100)
    #np.linspace()
    print(f)
    plt.plot(x_l, f(x_l), label='2500')
    plt.legend()

    from scipy import interpolate
    plt.figure(2)
    #temp = interpolate.interp1d(x, y)
    #ynew = temp(x)
    x_l = np.linspace(0, 4000, 100)
    temp = interpolate.splrep(x, y, s=0)
    ynew = interpolate.splev(x_l, temp, der=0)
    plt.plot(x_l, ynew)


    plt.figure(3)
    plt.imshow(rotated_image)
    #  plt.plot(images['2-1.tif'])
    plt.show()

# -------------------------------------------------------------------------



# построение гистограммы с выбором шиирины разбиения
#  ---------------------------------------------------------------------------
#     k = 25 #  количсетвто интервалов разбиения
#     h = cv.calcHist([images['2-1.tif']], [0], None, [k], [2, 254]) # 100 129 выбор интервала, в котором вычисляется гистограмма
#     plt.plot(h)
#     x = np.arange(k)
#     fig, ax = plt.subplots()
#     h = [h[i][0] for i in range(k)]
#     ax.bar(x, h)
#     plt.show()
#  ---------------------------------------------------------------------------



#  ---------------------------------------------------------------------------
# построение гистограммы с выбором шиирины разбиения
# строит столбчатую и кривую гистограмму и выводит эти два изображения
    k = 25 #  количсетвто интервалов разбиения
    h = cv.calcHist([images['2-1.tif']], [0], None, [k], [2, 254]) # 100 129 выбор интервала, в котором вычисляется гистограмма
    plt.plot(h)
    x = np.arange(k)
    fig, ax = plt.subplots()
    h = [h[i][0] for i in range(k)]
    ax.bar(x, h)
    plt.show()
#  ---------------------------------------------------------------------------



#  ---------------------------------------------------------------------------
# этот кусок исползовался чисто для построения графиков изменения чего то, от чего то
# наверное в отдельную функцию вынести это было бы лучше

# x = [0, 20, 40, 60]
# y1 = [113.438, 110.482, 111.628, 109.617]  # изменение мат ожидания при 40 сек экпонирования
# y2 = [105.348, 104.241, 105.979, 102.301]  # изменение мат ожидания при 50 сек экпонирования
# y3 = [97.337, 99.377, 96.806, 96.752]  # изменение мат ожидания при 60 сек экпонирования
# y4 = [96.337, 94.614, 96.011, 94.926]  # изменение мат ожидания при 70 сек экпонирования
#
# plt.plot(x, y1, label='T = 40 s')
# plt.plot(x, y2, label='T = 50 s')
# plt.plot(x, y3, label='T = 60 s')
# plt.plot(x, y4, label='T = 70 s')
#
# plt.legend(loc=1, shadow=True)
# plt.show()
#  ---------------------------------------------------------------------------



#  ---------------------------------------------------------------------------
# проверял схлодится ли значение СКО посчитанного мной и с помощью библиотеки
# не сходится из-за того, как хранятся данные об изображениях
# из нужно представлять в другом виде, чтобы пользоваться библиотекой (SciPy)
for i in range(4):
    mat = calc_mat_expectation(histograms[time_70s[i]])
    des = calc_dispersion(histograms[time_70s[i]], mat)
    sci = moment(histograms[time_70s[i]], moment=2)
    print(f'M[x] = {mat}    | D[x]= {des}   | CKO= {des ** 0.5}, | CKO_scipi= {sci}')

#  ---------------------------------------------------------------------------